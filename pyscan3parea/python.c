/*python main                */

parser_master_t* misc_parser=NULL;



// SPECIFIC PYTHON
// if python, 
//   if (m->misc_flex_try_again) return ; // the next symbol is expected: never the case because we do nothing in main_after_symbol_macro (if it was set for the previous SPACE, it is cleared on recursion)
// a) SEE b)
// store SPACE terminals in an array ( just use misc_parse_error_list, and an isSpace(terminal) function)
// when a non SPACE terminal is encountered, 'hang' the SPACE terminals before but NOT after on that non SPACE terminal: the tail SPACE terminals at the end of file store in an another variable. Use sym->user_attributes for the list of SPACE terminals which preceed the terminal. Use 'python_space_tail" for the list of tail spaces.
// Handling misc_parse_error_list: keep the position of the LAST SPACE terminal 'hang' on sym->user_attributes in 'python_last_listed_terminal', initially NULL.
// b) DO THIS FIRST, a) IS AN EXTENSION: moreover: it is not needeed, one kan cummulate spaces in a string, AND even better:output the terminal immediatelly via a callback (if a scanner is the target)
// examine amount of characters in SPACE terminals and create INDENT and DEDENT terminals:
//   -use a para-stack for {[( .   On any symbol }]), check that the stack top matches and pop.
//   -if the symbol is any newline (see docs: different for win,unix,...) then 
//        set flag 'scanning_begin_of_line' (initially false) (there may be multiple adjacent empty lines)
//   -if symbol is non-space and scanning_begin_of_line is set and para-stack is empty then the symbol is the beginning of new logical line: then calculate number of spaces from the last newline and use it in INDENT-DEDENT calculation below (use cummulated_spaces ) (newline is LF or CR LF or CR -all equal)
//   - Use indent_stack: stack of integers: initially 0 on the top, 0 is never popped: at the begin of each new 'logical' (skip empty lines) line calculate indent01 and then: 1) if greater than top of stack, push and give INDENT 2) if equal to top of stack, NOP 3) if less than top of stack, pop greater until 'equal' on top of stack (error if smaller on top); for each pop, emit DEDENT. At the end of file emit DEDENT for each positive on stack. The first line may not be indented.
// RULE: or NEWLINE is a token or it is added to the white space token
// RULE: empty lines do not need to be properly indented
// RULE: the first non-empty line must have indent=0 (no indent)

col_t *indent_stack=NULL,*para_stack=NULL, *cummulated_spaces=NULL;
long scanning_begin_of_line=1;
long empty_line=1;

// the following type is defined in *.h header of this file
static python_token_callback_type python_token_callback=NULL;
static long python_token_callback_mode=0;

// configuration function, type is defined in *.h header of this file
void python_specific_subscribe(long mode, python_token_callback_type callback){
//  mode = 1  dont send whitespace characters, i.e send only significant tokens
//  mode = 2  send all tokens
//  mode = 3  the complement of the mode 1, i.e send only the (whitespace) characters which are not the real python tokens
// remark: mode=-1 is used internally to indicate "no such mode" (see below python_use_callback)
	python_token_callback=callback;
	python_token_callback_mode=mode;	
}

static void python_specific_initialization(){
//init para_stack and indent_stack and scanning_begin_of_line
  indent_stack = stack_create ();
  {col_t *i=new_int(0);stack_push(indent_stack,i);} //0 on top of stack
  para_stack = stack_create ();
  cummulated_spaces = new_xstring (0,"");
  scanning_begin_of_line=1;
  empty_line=1; // a NEWLINE token is not generated if it ends a line with only space and/or comment
}

// use mode? == -1 for no mode
static void python_use_callback(long tok_id, col_t*tok_xstring, long mode1, long mode2){
     if (python_token_callback_mode==mode1 || python_token_callback_mode==mode2 ){
	if(python_token_callback){
            char*str01=val_xstring(tok_xstring);
	    long len01=length_xstring(tok_xstring);
            python_token_callback(tok_id,str01,len01);
        }
     }
}

// logical line is one or more lines connected by line continuation
// special tokens which are generated by this function. they carry the original characters
// TOK_SPACE_INDENT emitted if a candidate for INDENT or DEDENT, i.e. this is the space at the beginning of the logical line. It can be empty in the case of a logical line which begins at the first position. It does not need to really cause the INDENT or DEDENT because the previous line can have the same indentation.
// TOK_SPACE_EMPTY_LINE emitted if empty line
// TOK_SPACE_NO_INDENT emitted if at the beginning of line which is not the beginning of a logical line and thus makes no indent or dedent (because inside ({[])} )
// TOK_NEW_LINE_IGNORED emitted if makes no indent (because inside ({[])} ) (new line token should contain the original nl codes)
// TOK_SPACE_AT_END_OF_LINE emitted if non-empty space before new line (also if only logical line continuation)
// TOK_SPACE_OTHER emitted if space otherwise, for instance between words

static void python_specific_misc_macro_after_symbol(parser_master_t*m){
   pleaf_t sym01;
   //long emit_token=0;  //should a token be given to the user by callback?
   //long emit_whitespace_token=0;  //should a whitespace token be given to the user by callback?
   //long emitted_token=0;
   //char * emitted_token_text;
   sym01=m->yylval;	
   if (!sym01){
      //expected !0
      fprintf (stderr,"Expected sym01 not 0, fatal internal error");
      exit (1);
   }
   if (TOK_SPACE==sym01->id){
      cummulated_spaces=concat_xstring(cummulated_spaces,symbol_text3(sym01));
      m->misc_flex_try_again=1;//the token has been placed in misc_parse_error_list and later will be discarded
   }else if (TOK_EXIT==sym01->id){
      // this block we encounter twice: once to push all dedent at the end of file and once more to process posponed EXIT. TOK_EXIT is first discarded, then put at the end of the additional list
      int some_dedents_found=0;

      // handle cummulated spaces, if not empty,  'no NL at EOF case'
      char*str03=val_xstring(cummulated_spaces);
      if (strcmp(str03,"")){
        python_use_callback(TOK_SPACE_NO_INDENT,cummulated_spaces,2,3);//2,3 is for 'more' tokens
        col_unbound_col(cummulated_spaces);
        cummulated_spaces = new_xstring (0,"");	
      }

      while (1){
       long stacktop01;
       col_t*i;
       col_t* empty_string;
       i=stack_pop(indent_stack);
       if (!i) {
         fprintf (stderr,"Expected nonempty stack, fatal internal error");
         exit (1);
       }
       stacktop01=DER(val_int(i));col_unbound_col(i);
       if (!some_dedents_found && !stacktop01) break;
       if (some_dedents_found && !stacktop01){
         stack_push(indent_stack,new_int(0));
         m->misc_flex_try_again=1;	
         push_additional_token_list(m,TOK_EXIT,sym01->pos[0],sym01->pos[1]); //next time there will be no dedents and this EXIT will really exit. The last two arguments are not needed (could be: 0,0)
         break;
       }
       empty_string=new_xstring (0,"");
       //python_use_callback(TOK_DEDENT,empty_string,1,2); //1,2 is for 'real' tokens
       col_unbound_col(empty_string);
       push_additional_token_list(m,TOK_DEDENT,0,0);
       some_dedents_found=1;	
      }
   }else if (TOK_NEWLINE!=sym01->id){  // (and also not space)
     if (scanning_begin_of_line){
       scanning_begin_of_line=0;
       if (!stack_size(para_stack)){ //spaces at the beginning of the logical line
	  // calculate number of spaces in string
          //number of spaces with tab==8 spaces
          char*str01=val_xstring(cummulated_spaces);
	  long len01=length_xstring(cummulated_spaces);
          long cnt01=0;
          long number_of_spaces=0;
          long top_of_stack;

          for(;cnt01<len01;cnt01++){
            if(str01[cnt01]==' '){
                number_of_spaces++;
            }else if(str01[cnt01]=='\t'){
                number_of_spaces+=8-number_of_spaces%8;
            }else{
                //unexpected: not space nor tab
            }
          }
          //may be empty, so preceeds EVERY logical line
	  python_use_callback(TOK_SPACE_INDENT,cummulated_spaces,2,3);//2,3 is for 'more' tokens

          col_unbound_col(cummulated_spaces);
          cummulated_spaces = new_xstring (0,"");	

          //calculate INDENT/DEDENT:
          //push INDENT/DEDENT if needed
          //get the top of the stack
	  {col_t*i=stack_pop(indent_stack);top_of_stack=DER(val_int(i));stack_push(indent_stack,i);/*col_unbound_col(i);*/}
          
          {
           int any_indent_or_dedent=0;
           if (number_of_spaces>top_of_stack)
           {
            col_t* empty_string=new_xstring (0,"");	
  	    //python_use_callback(TOK_INDENT,empty_string,1,2); //1,2 is for 'real' tokens
            col_unbound_col(empty_string);
            stack_push(indent_stack,new_int(number_of_spaces));
            push_additional_token_list(m,TOK_INDENT,sym01->pos[0],sym01->pos[0]);//both 0!
            any_indent_or_dedent=1;
           }else while (number_of_spaces<top_of_stack)
           {
	    {col_t*i=stack_pop(indent_stack);top_of_stack=DER(val_int(i));col_unbound_col(i);}
	    {col_t*i=stack_pop(indent_stack);top_of_stack=DER(val_int(i));stack_push(indent_stack,i);/*col_unbound_col(i);*/}	
             col_t* empty_string=new_xstring (0,"");	
  	     //python_use_callback(TOK_DEDENT,empty_string,1,2); //1,2 is for 'real' tokens
             col_unbound_col(empty_string);
             push_additional_token_list(m,TOK_DEDENT,sym01->pos[0],sym01->pos[0]);//both 0!
             any_indent_or_dedent=1;
           }
	   // it could be the same indentation as in the previous line, then any_indent_or_dedent==0
           if (any_indent_or_dedent){
              m->misc_flex_try_again=1;
              push_additional_token_list(m,sym01->id,sym01->pos[0],sym01->pos[1]);
           }
          }
          // in any case: here must be number_of_spaces==top_of_stack
          if (top_of_stack!=number_of_spaces){
             //syntax error: wrong indentation
          }
       }else{//stack_size(para_stack)
         //TOK_SPACE_NO_INDENT(cummulated_spaces) #may be empty, so preceeds EVERY continuation inside a logical line
	 python_use_callback(TOK_SPACE_NO_INDENT,cummulated_spaces,2,3);//2,3 is for 'more' tokens
         col_unbound_col(cummulated_spaces);
         cummulated_spaces = new_xstring (0,"");	
       }
     }else{ //!scanning_begin_of_line
       // we also know that the current token is not a space, so emit cummulated spaces
       // push TOK_SPACE_OTHER(cummulated_spaces)
       char*str02=val_xstring(cummulated_spaces);
       if (strcmp(str02,"")){
	 python_use_callback(TOK_SPACE_OTHER,cummulated_spaces,2,3);//2,3 is for 'more' tokens
         col_unbound_col(cummulated_spaces);
         cummulated_spaces = new_xstring (0,"");	
       } 				
     }
     if (!m->misc_flex_try_again && TOK_COMMENT==sym01->id){
       //some special action, for instance ignore
         col_t*comment=NULL;
	 python_use_callback(sym01->id, comment=symbol_text3(sym01),2,3);//2,3 is for 'more' tokens
         col_unbound_col(comment);
         m->misc_flex_try_again=1;
     }
   }else {     //if (TOK_NEWLINE==sym01->id)
     if (scanning_begin_of_line){
         //push TOK_SPACE_EMPTY_LINE(cummulated_spaces) #may be empty, concatinate with NL
         cummulated_spaces=concat_xstring(cummulated_spaces,symbol_text3(sym01));
	 python_use_callback(TOK_SPACE_EMPTY_LINE,cummulated_spaces,2,3);//2,3 is for 'more' tokens
         col_unbound_col(cummulated_spaces);
         cummulated_spaces = new_xstring (0,"");	
         m->misc_flex_try_again=1;
     }else{ //!scanning_begin_of_line
         // check cummulated_spaces, if not "", push TOK_SPACE_AT_END_OF_LINE
         char*str03=val_xstring(cummulated_spaces);
         if (strcmp(str03,"")){
   	   python_use_callback(TOK_SPACE_AT_END_OF_LINE,cummulated_spaces,2,3);//2,3 is for 'more' tokens
           col_unbound_col(cummulated_spaces);
           cummulated_spaces = new_xstring (0,"");	
         }

     }
     if (!stack_size(para_stack)){
         //it is real  TOK_NEWLINE
     }else if(!scanning_begin_of_line){//stack_size(para_stack)
         //push TOK_NEW_LINE_IGNORED
         col_t*nl02=NULL;
	 python_use_callback(TOK_NEW_LINE_IGNORED, nl02=symbol_text3(sym01),2,3);//2,3 is for 'more' tokens
         col_unbound_col(nl02);
         m->misc_flex_try_again=1;
     }
     scanning_begin_of_line=1;

   }

   // the following conditional handles {[( }])
   if (TOK_OP==sym01->id||TOK_OB==sym01->id||TOK_AO==sym01->id){
     //push open para
     stack_push(para_stack,new_int(sym01->id));
   }else if (TOK_CP==sym01->id||TOK_CB==sym01->id||TOK_AC==sym01->id){
     // pop closed para
     col_t*i=stack_pop(para_stack);	
     if (i ){
       if(TOK_OP==val_int(i)&&TOK_CP!=sym01->id||TOK_OB==val_int(i)&&TOK_CB!=sym01->id||TOK_AO==val_int(i)&&TOK_AC!=sym01->id){
         fprintf (stderr,"Mismatched parantheses at line:%d",line_number_beg(sym01));
	 // here mention the line and solve exit in another way
         exit (1);
       }
       //here i has to be unbounded
       col_unbound_col(i);
     }else{
         fprintf (stderr,"Closed parantheses without any open at line:%d",line_number_beg(sym01));
	 // here mention the line and solve exit in another way
         exit (1);
     }
   }
   if(!m->misc_flex_try_again){
        col_t*sym_tmp=NULL;
        python_use_callback(sym01->id, sym_tmp=symbol_text3(sym01),1,2);//1,2 is for 'real' tokens
        col_unbound_col(sym_tmp);
   }

}

void python_stop(parser_master_t*m){ //m known?
   push_additional_token_list(m,TOK_EXIT,0,0);
}

// END SPECIFIC PYTHON



void python_main_init(int argc,char**argv)
{
#ifndef NDEBUG
  db_init();
#endif
  BEGIN_FUNCTION(python_main_init,0);
#ifndef NDEBUG
  fp_error = fopen(file_name("TEMP","/error"), "w+" );
#else
  fp_error=stderr;
#endif
  mm2_create();
  general_main_init();
  misc_parser=misc_new_parser(flex_getchar,misc_yylex,yy_lex);
#if !defined NDEBUG
   load_string_token_prop(); 
   load_token_string_prop(); 
#endif

#ifndef NDEBUG
  DEBUG_INITIALIZE();
#endif
   load_connecting_nonterminal2(misc_parser); 
#ifndef NDEBUG
  answ_tree = fopen(file_name("TEMP","/kk-nice-little-scratch-buffer_600102.el"), "w+" );
  fprintf(answ_tree,"%s",";begin\n");fflush(answ_tree);
#endif
  if (argc>1){
    open_text_file_for_read(misc_parser,argv[1],NULL);
  }else{
    open_text_file_for_read(misc_parser,"--",NULL);
    misc_parser->current_text_heap->file_ptr=stdin;
  }

  // SPECIFIC PYTHON
  python_specific_initialization();
  // END SPECIFIC PYTHON



  yyparse ((void*)misc_parser);
#ifndef NDEBUG
  fclose(fp_error);
#endif
  END_FUNCTION(python_main_init,return;,0);
}

/*unbound an extended type*/
//DOC_FUNC_DEF(col_extended_type_unbound DG_PARSE_COMMON)
long col_extended_type_unbound(col_t* s)
{
  BEGIN_FUNCTION(col_extended_type_unbound,2);
  long result=0;
/*   if(CPP_FILE_ATTP==s->type) */
/*     { */
/*     } */
/*   else */
    {
      ASSERT(0);
      EXIT_(1);
    }
  END_FUNCTION(col_extended_type_unbound,return result;,2);
}

/*to be done after terminal symbol*/
//DOC_FUNC_DEF(main_after_symbol_macro DG_PARSE_COMMON)
void main_after_symbol_macro(long *result)
{
}

/* To be done after received symbol from flex. It is called after running (A) or (B):
(A)(flex call, main_after_symbol_macro)
(B) additional_token_list. 
But it is called before looking at m->misc_flex_try_again where if true EVERYTHING is done once again recursively (in the later case, on recursion the p->misc_parse_error_list keeps the discarded token). */
//DOC_FUNC_DEF(misc_macro_after_symbol DG_PARSE_COMMON)
void misc_macro_after_symbol(parser_master_t*m)
{

// SPECIFIC PYTHON
  python_specific_misc_macro_after_symbol(m);
// END SPECIFIC PYTHON


}

